name: 'Git-Autoversion'
description: 'Automatically generate semantic versions based on git repository state'
author: 'Trond Hindenes'

branding:
  icon: 'hash'
  color: 'blue'

inputs:
  config:
    description: 'Path to configuration file (default: .autoversion.yaml)'
    required: false
    default: ''
  config-flags:
    description: 'Configuration flags to pass to autoversion (can be multiple, separated by newlines or commas)'
    required: false
    default: ''
  fail-on-error:
    description: 'Whether to fail the action if version calculation fails'
    required: false
    default: 'true'
  version:
    description: 'Specific version of autoversion to use (default: 1, can be "1", "1.0", "1.0.0", or "latest")'
    required: false
    default: '1'

outputs:
  semver:
    description: 'The calculated semantic version (e.g., 1.0.0 or 1.0.0-pre.0)'
    value: ${{ steps.autoversion.outputs.semver }}
  semverWithPrefix:
    description: 'The calculated semantic version with v prefix (e.g., v1.0.0 or v1.0.0-pre.0)'
    value: ${{ steps.autoversion.outputs.semverWithPrefix }}
  pep440:
    description: 'The calculated PEP 440 version (e.g., 1.0.0 or 1.0.0a0)'
    value: ${{ steps.autoversion.outputs.pep440 }}
  pep440WithPrefix:
    description: 'The calculated PEP 440 version with v prefix (e.g., v1.0.0 or v1.0.0a0)'
    value: ${{ steps.autoversion.outputs.pep440WithPrefix }}
  major:
    description: 'The major version number (e.g., 1)'
    value: ${{ steps.autoversion.outputs.major }}
  minor:
    description: 'The minor version number (e.g., 0)'
    value: ${{ steps.autoversion.outputs.minor }}
  patch:
    description: 'The patch version number (e.g., 0)'
    value: ${{ steps.autoversion.outputs.patch }}
  isRelease:
    description: 'Whether this is a release version (true/false)'
    value: ${{ steps.autoversion.outputs.isRelease }}

runs:
  using: 'composite'
  steps:
    - name: Run autoversion
      id: autoversion
      shell: bash
      run: |
        # Determine OS and architecture
        OS=$(uname -s | tr '[:upper:]' '[:lower:]')
        ARCH=$(uname -m)

        # Map architecture names to GitHub release naming convention
        case "$ARCH" in
          x86_64)
            ARCH="amd64"
            ;;
          aarch64|arm64)
            ARCH="aarch64"
            ;;
          *)
            echo "Error: Unsupported architecture $ARCH"
            exit 1
            ;;
        esac

        # Determine which version to use
        VERSION="${{ inputs.version }}"
        if [ -z "$VERSION" ] || [ "$VERSION" = "latest" ] || [ "$VERSION" = "1" ]; then
          # Fetch the latest release tag
          RELEASE_TAG=$(curl -s https://api.github.com/repos/trondhindenes/autoversion/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
          if [ -z "$RELEASE_TAG" ]; then
            echo "Error: Could not determine latest release"
            exit 1
          fi
        else
          # Use the specified version, adding 'v' prefix if not present
          if [[ "$VERSION" != v* ]]; then
            RELEASE_TAG="v$VERSION"
          else
            RELEASE_TAG="$VERSION"
          fi
        fi

        echo "Using autoversion version: $RELEASE_TAG"

        # Construct the archive name based on OS and architecture
        ARCHIVE_NAME="autoversion-${OS}-${ARCH}.tar.gz"
        DOWNLOAD_URL="https://github.com/trondhindenes/autoversion/releases/download/${RELEASE_TAG}/${ARCHIVE_NAME}"

        echo "Downloading from: $DOWNLOAD_URL"

        # Download the archive
        curl -L -o /tmp/autoversion.tar.gz "$DOWNLOAD_URL"
        if [ $? -ne 0 ]; then
          echo "Error: Failed to download autoversion archive"
          exit 1
        fi

        # Extract the binary
        tar -xzf /tmp/autoversion.tar.gz -C /tmp/
        if [ $? -ne 0 ]; then
          echo "Error: Failed to extract autoversion archive"
          exit 1
        fi

        # Make it executable
        chmod +x /tmp/autoversion

        # Run autoversion with appropriate arguments
        CONFIG_ARG=""
        if [ -n "${{ inputs.config }}" ]; then
          CONFIG_ARG="--config ${{ inputs.config }}"
        fi

        # Handle config flags (can be multiple)
        CONFIG_FLAGS_ARG=""
        if [ -n "${{ inputs.config-flags }}" ]; then
          # Replace commas and newlines with spaces, then process each flag
          FLAGS_INPUT="${{ inputs.config-flags }}"
          # Replace commas with newlines, then filter out empty lines
          FLAGS_LIST=$(echo "$FLAGS_INPUT" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | grep -v '^$')

          # Build the config flags argument string
          while IFS= read -r flag; do
            if [ -n "$flag" ]; then
              CONFIG_FLAGS_ARG="$CONFIG_FLAGS_ARG --config-flag $flag"
            fi
          done <<< "$FLAGS_LIST"
        fi

        FAIL_ON_ERROR="${{ inputs.fail-on-error }}"

        # Execute autoversion and capture JSON output
        if [ "$FAIL_ON_ERROR" = "true" ]; then
          JSON_OUTPUT=$(/tmp/autoversion $CONFIG_ARG $CONFIG_FLAGS_ARG)
        else
          JSON_OUTPUT=$(/tmp/autoversion $CONFIG_ARG $CONFIG_FLAGS_ARG || true)
        fi

        # Parse JSON output and set GitHub Action outputs
        echo "semver=$(echo "$JSON_OUTPUT" | jq -r '.semver')" >> "$GITHUB_OUTPUT"
        echo "semverWithPrefix=$(echo "$JSON_OUTPUT" | jq -r '.semverWithPrefix')" >> "$GITHUB_OUTPUT"
        echo "pep440=$(echo "$JSON_OUTPUT" | jq -r '.pep440')" >> "$GITHUB_OUTPUT"
        echo "pep440WithPrefix=$(echo "$JSON_OUTPUT" | jq -r '.pep440WithPrefix')" >> "$GITHUB_OUTPUT"
        echo "major=$(echo "$JSON_OUTPUT" | jq -r '.major')" >> "$GITHUB_OUTPUT"
        echo "minor=$(echo "$JSON_OUTPUT" | jq -r '.minor')" >> "$GITHUB_OUTPUT"
        echo "patch=$(echo "$JSON_OUTPUT" | jq -r '.patch')" >> "$GITHUB_OUTPUT"
        echo "isRelease=$(echo "$JSON_OUTPUT" | jq -r '.isRelease')" >> "$GITHUB_OUTPUT"

        # Clean up
        rm -f /tmp/autoversion /tmp/autoversion.tar.gz
