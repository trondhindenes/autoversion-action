name: 'Git-Autoversion'
description: 'Automatically generate semantic versions based on git repository state'
author: 'Trond Hindenes'

branding:
  icon: 'hash'
  color: 'blue'

inputs:
  config:
    description: 'Path to configuration file (default: .autoversion.yaml)'
    required: false
    default: ''
  fail-on-error:
    description: 'Whether to fail the action if version calculation fails'
    required: false
    default: 'true'
  version:
    description: 'Specific version of autoversion to use (default: 1, can be "1", "1.0", "1.0.0", or "latest")'
    required: false
    default: '1'

outputs:
  version:
    description: 'The calculated semantic version (e.g., 1.0.0 or 1.0.0-pre.0)'
    value: ${{ steps.autoversion.outputs.version }}
  major:
    description: 'The major version number (e.g., 1)'
    value: ${{ steps.autoversion.outputs.major }}
  minor:
    description: 'The minor version number (e.g., 0)'
    value: ${{ steps.autoversion.outputs.minor }}
  patch:
    description: 'The patch version number (e.g., 0)'
    value: ${{ steps.autoversion.outputs.patch }}
  prerelease:
    description: 'The prerelease identifier if present (e.g., pre.0 or feature-branch.1)'
    value: ${{ steps.autoversion.outputs.prerelease }}
  is-prerelease:
    description: 'Whether this is a prerelease version (true/false)'
    value: ${{ steps.autoversion.outputs.is-prerelease }}

runs:
  using: 'composite'
  steps:
    - name: Run autoversion
      id: autoversion
      shell: bash
      run: |
        # Determine OS and architecture
        OS=$(uname -s | tr '[:upper:]' '[:lower:]')
        ARCH=$(uname -m)

        # Map architecture names to GitHub release naming convention
        case "$ARCH" in
          x86_64)
            ARCH="amd64"
            ;;
          aarch64|arm64)
            ARCH="aarch64"
            ;;
          *)
            echo "Error: Unsupported architecture $ARCH"
            exit 1
            ;;
        esac

        # Determine which version to use
        VERSION="${{ inputs.version }}"
        if [ -z "$VERSION" ] || [ "$VERSION" = "latest" ] || [ "$VERSION" = "1" ]; then
          # Fetch the latest release tag
          RELEASE_TAG=$(curl -s https://api.github.com/repos/trondhindenes/autoversion/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
          if [ -z "$RELEASE_TAG" ]; then
            echo "Error: Could not determine latest release"
            exit 1
          fi
        else
          # Use the specified version, adding 'v' prefix if not present
          if [[ "$VERSION" != v* ]]; then
            RELEASE_TAG="v$VERSION"
          else
            RELEASE_TAG="$VERSION"
          fi
        fi

        echo "Using autoversion version: $RELEASE_TAG"

        # Construct the archive name based on OS and architecture
        ARCHIVE_NAME="autoversion-${OS}-${ARCH}.tar.gz"
        DOWNLOAD_URL="https://github.com/trondhindenes/autoversion/releases/download/${RELEASE_TAG}/${ARCHIVE_NAME}"

        echo "Downloading from: $DOWNLOAD_URL"

        # Download the archive
        curl -L -o /tmp/autoversion.tar.gz "$DOWNLOAD_URL"
        if [ $? -ne 0 ]; then
          echo "Error: Failed to download autoversion archive"
          exit 1
        fi

        # Extract the binary
        tar -xzf /tmp/autoversion.tar.gz -C /tmp/
        if [ $? -ne 0 ]; then
          echo "Error: Failed to extract autoversion archive"
          exit 1
        fi

        # Make it executable
        chmod +x /tmp/autoversion

        # Run autoversion with appropriate arguments
        CONFIG_ARG=""
        if [ -n "${{ inputs.config }}" ]; then
          CONFIG_ARG="--config ${{ inputs.config }}"
        fi

        FAIL_ON_ERROR="${{ inputs.fail-on-error }}"

        # Execute autoversion and capture outputs
        if [ "$FAIL_ON_ERROR" = "true" ]; then
          /tmp/autoversion $CONFIG_ARG
        else
          /tmp/autoversion $CONFIG_ARG || true
        fi

        # Clean up
        rm -f /tmp/autoversion /tmp/autoversion.tar.gz
